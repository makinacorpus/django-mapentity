#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Copyright (C) 2007-2025 Gaetan Delannay

# This file is part of Appy.

# Appy is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.

# Appy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with
# Appy. If not, see <http://www.gnu.org/licenses/>.

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
import hashlib, datetime

from ..px import Px
from .base import Base
from .user import User
from ..utils import No
from .fields import Show
from .query import Query
from .fields.pod import Pod
from .fields.rich import Rich
from .fields.file import File
from .fields.info import Info
from .document import Document
from .carousel import Carousel
from ..xml.escape import Escape
from .fields.group import Group
from ..ui.sidebar import Sidebar
from .fields.action import Action
from .fields.select import Select
from .fields.string import String
from .fields.boolean import Boolean
from .fields.integer import Integer
from .fields.ref import Ref, autoref
from ..utils import string as sutils
from .fields.computed import Computed
from .fields.phase import Page as FPage
from ..ui.layout import Layout, Layouts
from .workflow.standard import Anonymous

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
EXPR_ERR = 'Page "%s" (%s): error while evaluating page expression "%s" (%s).'
EDITED   = 'Page %d %s within %s.'
DELETED  = '%s deleted.'
TOK_REPL = ' (replaces deleted token %s)'
TOK_SET  = '%s :: Token %s set%s.'
TOK_BASE = '%s (token-protected) :: Access tentative'
TOK_NO   = f'{TOK_BASE} without token.'''
TOK_KO   = f'{TOK_BASE} with wrong token.'''

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
br = '<br/>'

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class Config:
    '''Part of the model config being specific to pages'''

    def __init__(self):
        # On any page, beyond workflow-based security, token, time-based
        # security may be enabled in complement. When it is the case, on such a
        # page, a token may be generated (called "pageToken" below), and shared
        # with some third-party software (TP). If the TP wants its users to
        # access the page, he builds a link to the page, where he adds a
        # parameter "_t_=<token>", and makes this link available to its users.
        # The link is valid during the current hour. <token> is computed as
        # explained hereatfer.
        #
        # 1) Build a string of the form <pageToken><YYMMDDHH>. <YYMMDDHH>
        #    represents the current date and hour. HH (the hour part) is between
        #    00 and 23.
        #
        # 2) Build a md5 hexadecimal digest from this string.
        #
        # Here is an example.
        #
        #    import hashlib, datetime
        #
        #    now = datetime.datetime.now().strftime('%Y%m%d%H')
        #    toHash = f'{pageToken}{now}'
        #    token = hashlib.md5(toHash.encode()).hexdigest()
        #
        self.tokensEnabled = False

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
class Page(Base):
    '''Base class representing a web page'''

    # By default, web pages are public
    workflow = Anonymous

    # Managers and Publishers may create pages
    creators = ['Manager', 'Publisher']

    pa = {'label': 'Page'}

    @staticmethod
    def getListColumns(tool):
        '''Show minimal info for the anonymous user'''
        if tool.user.isAnon(): return 'title',
        return 'title', 'expression', 'next', 'selectable*100px|', \
               'podable*80px|', 'viewCss*100px|'

    listColumns = getListColumns

    # An alternate, shorter list of columns
    listColumnsShort = 'title', 'expression', 'next', 'state'

    # The POD ouput
    doc = Pod(template='*model/pod/Page.odt', formats=('pdf',), show=False,
              layouts=Pod.Layouts.inline, freezeTemplate=lambda o,tpl: ('pdf',))

    @staticmethod
    def update(class_):
        '''Configure field "title"'''
        title = class_.fields['title']
        title.show = Show.EX
        title.label = 'Page'
        title.page.show = lambda o: True if o.allows('write') else 'view'
        title.page.sticky = True

    # The POD output appears inline in the sub-breadcrumb
    def getSubBreadCrumb(self):
        '''Display an icon for downloading this page (and sub-pages if any) as a
           POD.'''
        if self.podable: return self.getField('doc').doRender('view', self)

    def getSupBreadCrumb(self):
        '''Shows the token if any'''
        if not self.isEmpty('token') and \
           self.user.hasRole(self.model.publishers):
            text = self.translate('page_has_token',
                                  mapping={'token': self.token})
            return f'<span class="help" title="{text}">ðŸª™</span>'

    def getSupTitle(self, nav):
        '''Returns the same content as m_getSupBreadCrumb'''
        return self.getSupBreadCrumb()

    def getSubTitle(self):
        '''Render a link to the tied carousel and/or search'''
        r = []
        esc = Escape.xhtml
        for name in ('carousel', 'query'):
            if not self.isEmpty(name):
                o = getattr(self, name)
                label = self.translate(self.getField(name).labelId)
                r.append('<div class="discreet">%s: <a href="%s">%s</a></div>' \
                         % (esc(label), o.url, esc(o.getShownValue())))
        return '\n'.join(r)

    def getTitle(self, maxChars=None, nbsp=False):
        '''Returns p_self's title, shortened'''
        r = self.getShownValue()
        maxChars = maxChars or self.config.ui.pageChars
        r = Px.truncateValue(r, width=maxChars)
        if nbsp: r = r.replace(' ', 'Â ')
        return r

    # A warning: image upload is impossible while the page is temp
    warning = Info(show=lambda o: 'edit' if o.isTemp() else None,
                   focus=True, layouts=Info.Layouts.n, **pa)

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                               Token
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # See documentation in class Config hereabove.

    # The page token that one may generate for this page and sub-pages,
    # recursively.

    def tokensEnabled(self):
        '''Are page tokens enabled ?'''
        return self.config.model.page.tokensEnabled

    def showToken(self):
        '''Show the token on the XML layout only'''
        # Indeed, it appears in a specific way via methods m_getSupTitle and
        # m_getSupBreadCrumb.
        if self.token and self.user.hasRole(self.model.publishers):
            return 'xml'

    token = String(show=showToken, **pa)

    def getToken(self):
        '''Return the token that applies on p_self. It may be a token defined on
           a parent page.'''
        if not self.tokensEnabled(): return
        r = self.token
        if r: return r
        parent = self.parent
        return parent.getToken() if parent else None

    def getTimeBasedToken(self):
        '''Compute and return the time-based token being, now, valid'''
        pageToken = self.token
        now = datetime.datetime.now().strftime('%Y%m%d%H')
        toHash = f'{pageToken}{now}'
        return hashlib.md5(toHash.encode()).hexdigest()

    def getTokenKoText(self):
        '''Returns the translated text to return to the user when token-based
           security prevents him from acecssing this page.'''
        base = self.translate('unconsultable')
        more = self.translate('page_token_ko')
        return f'{base}{br*2}{more}'

    def tokenAllows(self):
        '''Returns True if token protection succeeds on p_self'''
        # Get the token for p_self
        token = self.getToken()
        if not token:
            # No token-based protection is defined on p_self: return True
            return True
        # Bypass token security for publishers
        if self.user.hasRole(self.model.publishers): return True
        # Get the time-based token that must be in the request
        reqToken = self.req._t_
        if not reqToken:
            self.log(TOK_NO % self.strinG(path=False), type='warning')
            return No(self.getTokenKoText())
        # Compute the time-based value corresponding to our v_token
        timeBased = self.getTimeBasedToken()
        if reqToken != timeBased:
            self.log(TOK_KO % self.strinG(path=False), type='warning')
            return No(self.getTokenKoText())
        return True

    def showSetToken(self):
        '''Show action "set token" to publishers only, for a public page only'''
        if not self.tokensEnabled(): return
        return 'buttons' if self.user.hasRole(self.model.publishers) else None

    def storeToken(self):
        '''Generates a token and stores it in p_self.token'''
        old = self.token
        self.token = token = sutils.randomName(8)
        suffix = TOK_REPL % old if old else ''
        self.log(TOK_SET % (self.strinG(path=False), token, suffix))
        message = self.translate('page_token_set', mapping={'token': token})
        if old:
            more = self.translate('page_token_repl', mapping={'token': old})
            message = f'{message}{br*2}{more}'
        self.say(message, fleeting=False)

    setToken = Action(action=storeToken, show=showSetToken, confirm=True, **pa)

    def showDelToken(self):
        '''Show action "delete token" to publishers only, if a token is set'''
        if not self.tokensEnabled(): return
        if self.token and self.user.hasRole(self.model.publishers):
            return 'buttons'

    def deleteToken(self):
        '''Deletes p_self.token'''
        self.token = None

    delToken = Action(action=deleteToken, show=showDelToken, confirm=True, **pa)

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                           Linked carousel
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    def showCarousel(self):
        '''Show field "carousel" if carousels are defined'''
        if self.tool.isEmpty('carousels'): return
        # Do not show it (except on "edit") if there is no tied carousel
        return True if not self.isEmpty('carousel') else 'edit'

    carousel = Ref(Carousel, add=False, link=True, render='links',
      select=lambda o: o.tool.carousels, shownInfo=Carousel.pageListColumns,
      show=showCarousel, layouts=Layouts.fvd,
      view=Px('''<x var="o=o.carousel">:o.pxView</x>'''),
      back=Ref(attribute='pages', multiplicity=(0,None), render='links',
               group=Carousel.mainGroup, label='Carousel'), **pa)

    #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    #                            Page content
    #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    content = Rich(documents='documents', height='350px', inject=True,
                   show=lambda o: 'edit' if o.isEmpty('content') else True,
                   viewCss=lambda o: o.viewCss, viewSingle=True,
                   layouts=Rich.Layouts.f, **pa)

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                            Linked search
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    def showQuery(self):
        '''Show field "query" if queries are defined'''
        if self.tool.isEmpty('queries'): return
        # Do not show it (except on "edit") if there is no tied carousel
        return True if not self.isEmpty('query') else 'edit'

    query = Ref(Query, add=False, link=True, render='links',
      select=lambda o: o.tool.queries, shownInfo=Query.pageListColumns,
      show=showQuery, layouts=Layouts.fvd,
      view=Px('''<x var="o=o.query">:o.pxView</x>'''),
      back=Ref(attribute='pages', multiplicity=(0,None), render='links',
               group=Query.mainGroup, label='Query'), **pa)

    def forRootOnEdit(self):
        '''Determines visibility of some fields, on the "edit" layout, for root
           pages only.'''
        return Show.V_ if self.isRoot() else None

    # Is this (root) page selectable in the main dropdown ?
    selectable = Boolean(default=True, show=forRootOnEdit,
                         layouts=Boolean.Layouts.d, **pa)

    # Is PDF POD export enabled for this page ? Sub-pages can be individually
    # exported.
    podable = Boolean(layouts=Boolean.Layouts.d, show=Show.V_, **pa)

    # Maximum width for images uploaded and rendered within the XHTML content
    maxWidth = Integer(default=Document.maxImageWidth, show=False)

    # If this Python expression returns False, the page can't be viewed

    def showExpression(self):
        '''Show the expression to managers only'''
        # Do not show it on "view" if empty
        if self.isEmpty('expression'): return Show.V_
        return self.allows('write')

    expression = String(layouts=Layouts.d, show=showExpression, **pa)

    def expressionAllows(self):
        '''Returns True if p_self.expression allows viewing p_self'''
        expression = self.expression
        if not expression: return True
        user = self.user
        try:
            return eval(expression)
        except Exception as err:
            message = EXPR_ERR % (self.title, self.id, expression, str(err))
            self.log(message, type='error')
            return True

    # Name of the CSS class applied to the page content, when rendered on view
    # or cell layouts.
    viewCss = String(default='xhtml', layouts=Layouts.d, show=Show.V_, **pa)

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                             Inner images
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # The images (or other documents) that may be included in field "content"
    documents = Ref(Document, add=True, link=False, multiplicity=(0,None),
      composite=True, back=Ref(attribute='page', show=False, label='Document'),
      showHeaders=True, shownInfo=Document.listColumns, actionsDisplay='inline',
      page=FPage('images', show=lambda o:'view' if o.allows('write') else None),
      rowAlign='middle', **pa)

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                           Background image
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # In most cases, when a page is shown, like any other object, the background
    # image possibly applied is baseBG.jpg. On public root pages, no background
    # is shown: the one uploaded here may be used instead.
    bip = {'page': FPage('bg', show=lambda o: o.allows('write') and o.isRoot()),
           'group': Group('main', style='grid', hasLabel=False),
           'layouts': Layouts.gd }
    bip.update(pa)

    backgroundImage = File(isImage=True, viewWidth='700px', cache=True, **bip)

    # When the background image hereabove is used, the following parameter
    # determines how it is rendered. It is the equivalent of CSS attribute
    # "background-size".
    backgroundSize = Select(validator=('cover', 'auto'), default='cover', **bip)

    def initialiseLocalPage(self, req):
        '''A page can be specifically rendered as a root public page or as
           an inner page of such a root page. In these cases, the rendering
           context must be adapted.'''
        # p_self may propose a specific background image
        if not self.isEmpty('backgroundImage'):
            style = 'background-image:url(%s/backgroundImage/download); ' \
                    'background-repeat:no-repeat; background-size:%s' % \
                    (self.url, self.backgroundSize)
        else:
            style = None
        # Use a minimal page layout that only includes the "w" part (=widgets)
        req.pageLayout = Layout('w', style=style)
        # Avoid including global page elements: they have already been included
        # by the enclosing element.
        req.notGlobal = True

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                              Next page
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # Pages can be chained, in order to produce a single, composite page.
    # Chained pages must all be in the same container object.

    def listSiblings(self):
        '''Returns the pages being p_self's siblings'''
        return [page for page in self.container.pages if page != self]

    def hasContainer(self):
        '''Some fields can't be shown while a page has no container, which can
           happen when creating a page from the porlet.'''
        return Show.V_ if self.container else None

    next = Ref(None, add=False, link=True, layouts=Layouts.fvd, render='links',
               back=Ref(attribute='previous', render='links',
                        label='Page', show=Show.VE_),
               show=hasContainer, select=listSiblings, **pa)

    def getChain(self):
        '''Returns the list of pages being chained to p_self via "next" fields,
           recursively.'''
        r = [self]
        next = self.next
        return r + next.getChain() if next else r

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                              Sub-pages
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # A page can contain sub-pages
    def showSubPages(self):
        '''For non-writers, show sub-pages only if present'''
        if self.allows('write'):
            # Show it, unless the page is rendered as the next page of a
            # previous one.
            return not self.req.notGlobal
        if not self.isEmpty('pages'): return 'view'

    pages = Ref(None, multiplicity=(0,None), add=True, link=False,
      composite=True, back=Ref(attribute='parent', show=False, **pa),
      showHeaders=True, actionsDisplay='inline', show=showSubPages,
      numbered=True, checkboxes=lambda o: o.allows('write'),
      titleMode=lambda o: 'plink' if o.container.inPublic(True) else 'link',
      toggleSubTitles=False, **pa)

    def getParents(self, includeMyself=True):
        '''Returns, as a set, p_self's parents, including p_self itself if
           p_includeMyself is True.'''
        r = {self} if includeMyself else set()
        return r if self.isRoot() else r.union(self.container.getParents())

    def getMergedContent(self, r=None, level=1):
        '''Returns a list of chunks of XHTML code, one for p_self and one for
           each of its sub-pages, recursively.'''
        # More precisely, the r_result is a list of tuples of the form
        #
        #                   ~(xhtmlChunk, i_delta)~
        #
        #, "delta" being the delta to apply to the title's outline levels,
        # depending on the depth of the page within the complete tree of pages.
        #
        # p_level is the current level of recursion, while p_r is the current
        # list under creation. Indeed, in order to avoid concatenating lists, at
        # each m_getMergedContent call, the current p_r(esult) is passed.
        #
        # This method is notably called by appy/model/pod/Page.odt
        if r is None:
            # We are at the start of a recursive merge: there is no result yet.
            # Create it.
            r = []
        # Two pieces of information must be collected about p_self: its title
        # and content.
        if level > 1:
            # At level 1, do not dump the title
            title = self.getValue('title', type='shown')
            r.append((f'<h1>{Escape.xhtml(title)}</h1>', level-2))
        # Add p_self's content
        if not self.isEmpty('content'):
            r.append((self.getValue('content', type='shown'), level-1))
        # Add sub-pages
        if not self.isEmpty('pages'):
            for page in self.pages:
                page.getMergedContent(r, level=level+1)
        return r

    # Link allowing, when a sub-page is shown in the "public" PX, to go back to
    # the parent page.

    def showToParent(self):
        '''Show link "to parent" on a sub-page being rendered via the
           "public" PX.'''
        return 'view' if self.parent and self.inPublic() else None

    def getToParent(self):
        '''Get a link allowing to navigate to p_self's parent page'''
        text = self.getLabel('toParent')
        url = self.parent.getAccessUrl()
        return f'<a href="{url}">â†¥ {text}</a>'

    toParent = Computed(show=showToParent, method=getToParent, layouts='f')

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                                Editors
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # "Editors" are users being allowed to edit this page and its sub-pages.
    # These users are granted local role Owner on the page and its sub-pages. If
    # you use an alternate worklow for pages, ensure role Owner may edit pages.

    def linkEditor(self, user):
        '''Set this new editor as p_self's owner'''
        self.localRoles.add(user.login, 'Owner')
        for page in self.pages:
            page.linkEditor(user)

    def unlinkEditor(self, user):
        '''ungrant to p_user the possibility to edit p_self'''
        if user.login != self.creator:
            self.localRoles.delete(user.login, 'Owner')
        for page in self.pages:
            page.unlinkEditor(user)

    # Users allowed to edit this page and its sub-pages
    editors = Ref(User, add=False, link='popup', multiplicity=(0,None),
      afterLink=linkEditor, afterUnlink=unlinkEditor,
      back=Ref(attribute='editablePages', multiplicity=(0,None),
               page=FPage('editablePages', show=User.showEPages),
               layouts=Layouts.dv, actionsDisplay='inline',
               showHeaders=True, shownInfo=listColumnsShort, label='User'),
      showHeaders=True, shownInfo=User.listColumnsShort,
      actionsDisplay='inline', layouts=Layouts.dv,
      page=FPage('editors',
                 show=lambda o: 'view' if o.user.hasRole('Manager') else None),
      **pa)

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                               Navigation block
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # The navigation block allows to navigate from a given page to its siblings.
    # Ths scope is wider than Ref navigation: the objective is to navigate into
    # a complete tree of pages, having any depth level. For example, for a page 
    # being the last one in a Ref::pages, the "next" button may still appear if
    # the container page has a sibling.

    def showNavBlock(self):
        '''Must the navigation block be shown ?'''
        # Not for a page being in a chain or rendered in the public PX
        if self.next or self.previous or self.inPublic(): return
        return 'view'

    navPx = Px('''
     <div class="navBlock">
       <a var="sibling=o.getSibling(prev=True, tree=True)" if="sibling"
          class="navIcon" var2="prefix=_('Page_previous')" href=":sibling.url"
          title=":f'{prefix}: {sibling.getShownValue()}'">â‡ </a>
       <a var="sibling=o.getSibling(prev=False, tree=True)" if="sibling"
          class="navIcon" var2="prefix=_('Page_next')" href=":sibling.url"
          title=":f'{prefix}: {sibling.getShownValue()}'">â‡¢</a>
     </div>''',

     css='''.navBlock { position:fixed; bottom:0; right:0.8em; z-index:2;
                        background-color:|brightColor|; opacity:0.6 }
            .navIcon { font-size:200%; padding:0.2em; cursor:pointer }
        ''')

    navBlock = Computed(show=showNavBlock, method=navPx, layouts='f')

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                               Main methods
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # The URL path to the public PX
    publicPath = ['tool', 'public']

    def getAccessUrl(self, forcePublic=False):
        '''Return the URL being appropriate to access p_self, one of p_self.url
           and the one shown via the tool's public PX.'''
        if self.config.ui.discreetLogin:
            public = forcePublic
        else:
            ctx = self.traversal.context
            if ctx and ctx.inSidebar:
                public = False
            else:
                public = self.user.isAnon()
        return f'{self.tool.url}/public?rp={self.iid}' if public else self.url

    def inPortlet(self, selected, level=0):
        '''Returns a chunk of XHTML code for representing this page in the
           portlet, in a root class zone.'''
        # Is this page currently selected ? A selected page is the page being
        # currently consulted on the site or any of its parent pages.
        isSelected = self in selected
        # A specific CSS class wil be applied for a selected page
        css = ' class="currP"' if isSelected else ''
        # Collect CSS classes to apply to the main "div" tag containing the page
        # link.
        divCss = []
        if level:
            # If p_self has parents, we must render it with a margin-left
            divCss.append('pDelta')
        url = self.getAccessUrl()
        title = Escape.xhtml(self.getShownValue())
        guard = self.guard
        if isSelected and not self.isEmpty('pages'):
            subs = [sub.inPortlet(selected, level+1) \
                    for sub in self.pages if guard.mayView(sub)]
            subs = ''.join(subs)
            # Add a CSS class indicating that this page is a *c*ontainer for
            # sub-pages.
            divCss.append('pageC')
            onClick = ''
        else:
            subs = ''
            # Clicking on the div triggers a click on the inner link
            onClick = ' onclick="this.firstChild.click()"'
        divCss = ' '.join(divCss)
        divCss = f' class="{divCss}"' if divCss else ''
        return f'<div{divCss}{onClick}><a href="{url}"{css}>{title}</a>' \
               f'{subs}</div>'

    def isRoot(self):
        '''Is p_self a root page ?'''
        # A page created from the portlet (if class Page is declared as root)
        # has no container when under creation.
        container = self.container
        return not container or container.class_.python != Page

    def getRootObject(self):
        '''Returns the root object from which the tree of pages, that includes
           self, starts.'''
        cont = self.container
        if not cont: return
        return cont.getRootObject() if cont.class_.python == Page else cont

    def inPublic(self, orParent=False):
        '''Is p_self (or one of its parents if p_orParent is True) currently
           shown on the "public" page ?'''
        # Get the ID of the page being currently shown on the "public" page
        rp = self.req.rp
        if not rp: return
        # Does v_rp correspond to p_self ?
        r = rp == str(self.iid)
        if r: return r
        # [only if p_orParent is True] Does p_rp correspond to some ancestor of
        #                              p_self ?
        if orParent and self.parent:
            r = self.parent.inPublic(orParent=True)
        return r

    def mayView(self):
        '''In addition to the workflow, it may not be possible to view p_self
           due to p_self.expression or due to token protection.'''
        # Note that m_tokenAllows, instead of returning a boolean value, will
        # raise a MessageException if token security fails. That way, the
        # user will never be redirected to the login page.
        return self.expressionAllows() and self.tokenAllows()

    def onEdit(self, created):
        '''Link the page among root pages if created from the portlet'''
        if created and not self.initiator:
            self.tool.link('pages', self)
        verb = 'created' if created else 'edited'
        self.log(EDITED % (self.id, verb, self.container.iid))

    def onDelete(self):
        '''Log the page deletion'''
        self.log(DELETED % self.strinG())

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                                    PXs
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # This selector allows to choose one root page among published tool.pages
    pxSelector = Px('''
      <a for="page in pagesL" title=":page.getShownValue()"
         href=":page.url if inlaidHeader else page.getAccessUrl(True)">
       <span class=":'upage' if page.inPublic() else
         ('current' if o==page else '')">:page.getTitle(nbsp=True)</span>
      </a>
      <select onchange="gotoURL(this)" if="pagesO">
       <option value="">:_('goto_link')</option>
       <option for="page in pagesO"
               value=":page.url if inlaidHeader else page.getAccessUrl(True)"
               selected=":o == page if inlaidHeader else page.inPublic()"
               title=":page.getShownValue()">:page.getTitle(
                 maxChars=config.ui.pageCharsS)</option>
      </select>''',

     css = '''.upage { text-decoration:underline #afb8d4;
                       text-underline-offset:6px }''',
     js='''
       function gotoURL(select) {
         var url = select.value;
         if (url) goto(url);
       }''')

    # PX showing all root pages in the portlet, when shown for pages
    portletBottom = Px('''
     <div class="pageS"
          var="pages=pages|tool.OPage.getRoot(tool, mobile, splitted=False)">
      <x if="pages"
         var2="selected=o.getParents() if o.class_.python==tool.OPage else {}">
       <x for="page in pages"
          if="guard.mayView(page)">::page.inPortlet(selected)</x>
      </x>
      <i if="not pages">:_('no_page')</i>
     </div>''',

     css='''
       .pageS { margin-top:0.5em }
       .pageS div.pDelta { margin-left: 0.8em; font-size:95% }
       .pageC { border-left: 1px dashed grey }
       .pageS div:hover:not(.pageC) { background-color:|evenColor|;
                                      cursor:pointer }
       .currP { font-weight:bold; border-left:1px solid white; margin-left:-1px;
                padding-top:2px }
     ''')

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                                 Sidebar
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    # Disabled by default, the page sidebar may be enabled by an app when it
    # uses pages in a specific container object (for example, in a software
    # forge, every project may define documentation pages). In that case, the
    # sidebar will render the complete tree of pages on any of the contained
    # pages, including sub-pages at any depth.

    @classmethod
    def getSidebar(class_, o, layout):
        '''Render a sidebar on page p_o'''
        if layout == 'view':
            return Sidebar(width=320, maxWidth=420)

    sidebar = None # Activate the sidebar by setting m_getSidebar here. If you
                   # want to define your own dimensions for the sidebar, define
                   # your own method.

    sidePages = Computed(method=portletBottom, show='sidebar',
                         context=lambda o: {'pages': o.getRootObject().pages},
                         layouts=Layouts.w)

    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    #                              Class methods
    #  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

    @classmethod
    def getRoot(class_, tool, mobile, splitted=True):
        '''Return the root, selectable pages being visible by the logged user,
           among the site's root pages from p_tool.pages.'''
        # If p_splitted is True, pages will be returned in 2 distinct lists:
        # - the first one will contain those that must be rendered as "a" tags;
        # - the second one will contain those that must be rendered as options
        #   in a HTML "select" control.
        #
        # Choosing which page to put in which list is determined by parameter
        # p_tool.config.expandedRootPages.
        #
        # Return the cached version if available
        key = 'appyRootPagesS' if splitted else 'appyRootPages'
        cache = tool.cache
        if key in cache: return cache[key]
        if splitted:
            # Compute 2 sub-lists
            links = []
            options = []
            # Determine the maximum number of pages to render as links
            linksCount = 0 if mobile else tool.config.ui.expandedRootPages
        else:
            # Return a single list
            r = []
        # Walk root pages
        guard = tool.guard
        for page in tool.pages:
            # Ignore the page, if unselectable or unviewable
            if not page.selectable or not guard.mayView(page): continue
            if splitted:
                # Put the page in v_links or v_options
                if linksCount == 0:
                    options.append(page)
                else:
                    links.append(page)
                    linksCount -= 1
            else:
                r.append(page)
        # Cache and return the result
        if splitted:
            r = (links, options)
        cache[key] = r
        return r

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
autoref(Page, Page.next)
autoref(Page, Page.pages)
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
